# VIBE-X 통합 협업 플랫폼 — 세부 작업 기획안

> **팀 바이브제왕** | 작성일: 2026.02.12 | 버전: v1.0  
> 기반 문서: VibeCoding_Improvement_Proposal v1.0 (2026.02.11)

---

## 1. 프로젝트 개요

### 1.1 목표
Agent + MCP + RAG + Collaboration 기술을 5-Layer 구조로 통합하여,  
바이브 코딩의 구조적 한계(모델 품질 격차 + 팀 협업의 벽)를 동시에 해결하는 **VIBE-X 통합 협업 플랫폼**을 구축한다.

### 1.2 핵심 가치
| 지표 | 현재 (Opus×5, 시스템 없음) | 목표 (VIBE-X + Sonnet×5) |
|------|---------------------------|--------------------------|
| 월 비용 | ~$750 | ~$108 (86% 절감) |
| 아키텍처 일관성 | 40% | 90% |
| 통합 충돌률 | 45% | 12% |
| 설계 결정 추적률 | 10% | 85% |
| 온보딩 시간 | 2~3주 | 2~3일 |

### 1.3 전체 일정 요약
| Phase | 기간 | 비용 | 산출물 |
|-------|------|------|--------|
| Phase 1 | Day 1 (3시간) | $0 | 팀 문서 체계, PACT-D 프레임워크 |
| Phase 2 | Week 1~2 | $0 | RAG 메모리 엔진, 기본 품질 게이트 |
| Phase 3 | Month 1~2 | 저비용 | 멀티 Agent 자동화, MCP 오케스트레이터 |
| Phase 4 | Month 3~6 | 중비용 | 대시보드 웹 앱, IDE 플러그인 |

---

## 2. Phase 1 — 즉시 적용 (Layer 1: 구조화 프롬프트 & 스캐폴딩)

> **목표:** 팀 규칙과 구조화 문서 기반 마련  
> **소요:** 3시간 | **비용:** $0

### Task 1.1 — 프로젝트 정의 문서 작성
- **담당:** 팀 리드
- **산출물:** `project-definition.md`
- **내용:**
  - 프로젝트 목적 및 비전
  - 기술 스택 정의 (언어, 프레임워크, 인프라)
  - 팀 구성원 역할 정의
  - 마일스톤 및 릴리즈 계획
- **완료 기준:** 팀 전원 리뷰 및 승인

### Task 1.2 — 아키텍처 맵 작성
- **담당:** 시니어 개발자
- **산출물:** `architecture-map.md`
- **내용:**
  - 디렉토리 구조 표준
  - 모듈 간 의존성 다이어그램
  - 데이터 흐름도
  - API 엔드포인트 명세
  - 상태 관리 전략
- **완료 기준:** 모듈 간 관계가 명확히 정의됨

### Task 1.3 — 코딩 규칙 문서 작성
- **담당:** 팀 전원 합의
- **산출물:** `coding-rules.md`
- **내용:**
  - 네이밍 컨벤션 (파일, 변수, 함수, 컴포넌트)
  - 코드 스타일 (포매터, 린터 설정)
  - 금지 패턴 목록
  - 에러 핸들링 표준
  - 보안 체크리스트
- **완료 기준:** `.cursorrules`에 규칙 자동 주입 설정 완료

### Task 1.4 — ADR(Architecture Decision Record) 운영 체계 구축
- **담당:** 팀 리드
- **산출물:** `docs/adr/` 디렉토리 + ADR 템플릿
- **내용:**
  - ADR 템플릿 작성 (제목, 상태, 컨텍스트, 결정, 결과)
  - 첫 번째 ADR 작성: "기술 스택 선정 근거"
  - ADR 작성 프로세스 정의
- **완료 기준:** 팀원 누구나 ADR을 작성할 수 있는 상태

### Task 1.5 — PACT-D 프레임워크 적용
- **담당:** 팀 전원
- **산출물:** PACT-D 프롬프트 템플릿
- **내용:**
  - P(Purpose): 코드가 해결하는 문제 명시 템플릿
  - A(Architecture): 관련 파일, 기존 패턴, ADR 참조 체크리스트
  - C(Constraints): 팀 코딩 규칙 자동 주입 설정
  - T(Test): 성공 기준 및 테스트 시나리오 정의 양식
  - D(Dependency): 팀원 작업 의존성 확인 프로세스
- **완료 기준:** 모든 AI 프롬프트에 PACT-D가 포함되는 워크플로우 확립

### Task 1.6 — memory.md 자동 기록 설정
- **담당:** 개발 환경 담당자
- **산출물:** `.cursorrules` 업데이트
- **내용:**
  - 매 3회 대화마다 기록 프롬프트 자동 삽입 설정
  - `memory.md` 파일 구조 정의
  - 기록 항목: 결정사항, 패턴 선택 이유, 주의사항
- **완료 기준:** Sonnet 모델에서도 컨텍스트 유지율 95% 달성

---

## 3. Phase 2 — 기반 구축 (Layer 2: Living RAG Memory Engine)

> **목표:** 코드베이스를 질문 가능한 지식 베이스로 전환  
> **소요:** 1~2주 | **비용:** $0

### Task 2.1 — Vector DB 환경 구축
- **담당:** 백엔드 개발자
- **기술 스택:** LanceDB 또는 ChromaDB (임베디드 모드)
- **작업 내용:**
  1. Vector DB 선택 및 설치
  2. 스키마 설계 (코드 청크, 메타데이터, 임베딩 벡터)
  3. 인덱스 전략 수립 (파일 단위 vs 함수 단위 vs 블록 단위)
  4. 검색 API 설계
- **완료 기준:** 로컬에서 임베딩 저장/검색이 정상 동작

### Task 2.2 — 임베딩 파이프라인 구축
- **담당:** ML/데이터 엔지니어
- **기술 스택:** Voyage-code-3 임베딩 모델
- **작업 내용:**
  1. 임베딩 모델 선택 및 API 설정
  2. 코드 파싱 전략 (AST 기반 vs 텍스트 기반)
  3. 청킹 전략 (함수 단위, 클래스 단위, 파일 단위)
  4. 메타데이터 추출 (파일 경로, 작성자, 최종 수정일, 의존성)
- **완료 기준:** 테스트 코드베이스 임베딩 완료 및 유사도 검색 정확도 80%+

### Task 2.3 — 기존 코드베이스 전체 임베딩
- **담당:** 백엔드 개발자
- **기술 스택:** LangChain 또는 LlamaIndex
- **작업 내용:**
  1. 전체 코드베이스 스캔 및 파싱
  2. 코드 + 문서 + ADR + memory.md 벡터화
  3. 증분 인덱싱 전략 구현 (변경된 파일만 재임베딩)
  4. 인덱싱 상태 모니터링 스크립트
- **완료 기준:** 전체 코드베이스가 벡터 DB에 인덱싱 완료

### Task 2.4 — Git Hook 기본 품질 게이트 설정
- **담당:** DevOps / 개발 환경 담당자
- **기술 스택:** Husky (Git Hooks)
- **작업 내용:**
  1. Husky 설치 및 초기 설정
  2. **Gate 1 (Syntax Agent):** pre-commit에 린터 + 타입 검사 연동
  3. **Gate 2 (Rules Agent):** 팀 코딩 규칙 자동 검증 스크립트
  4. **Gate 5 (Architecture Agent):** ADR 정합성 검사
- **완료 기준:** 규칙 위반 커밋 시 자동 차단

### Task 2.5 — Hidden Intent File 시스템 구축
- **담당:** 풀스택 개발자
- **산출물:** `.meta.json` 자동 생성 시스템
- **작업 내용:**
  1. `.meta.json` 스키마 정의 (의도, 설계 결정, 대안, 제약조건)
  2. `/gen-with-meta` 커맨드 구현
  3. AI 코드 생성 시 메타데이터 동시 생성 워크플로우
  4. Git Hook으로 `.meta.json` → Vector DB 자동 인덱싱
- **완료 기준:** 코드 생성 시 메타데이터가 자동으로 기록되고 검색 가능

### Task 2.6 — RAG 질의 인터페이스 구현
- **담당:** 풀스택 개발자
- **작업 내용:**
  1. "이 함수는 왜 이렇게 구현되었나?" 형태의 자연어 질의 지원
  2. 컨텍스트 검색 → LLM 응답 생성 파이프라인
  3. IDE 내 `@Codebase` / `@Memory` 컨텍스트 연동
  4. 검색 결과 정확도 피드백 루프
- **완료 기준:** 자연어로 코드 의도 질의 가능, 정확도 75%+

---

## 4. Phase 3 — Agent 자동화 (Layer 3 + Layer 4)

> **목표:** 멀티 Agent 품질 게이트 완전 자동화 + MCP 협업 오케스트레이터 구축  
> **소요:** 1~2개월 | **비용:** 저비용

### Task 3.1 — MCP 서버 설계 및 구축
- **담당:** 백엔드 아키텍트
- **작업 내용:**
  1. MCP 프로토콜 사양 분석 및 설계
  2. MCP 서버 코어 구현 (메시지 라우팅, 상태 관리)
  3. Agent 등록/해제 인터페이스
  4. 팀 컨텍스트 동기화 프로토콜 구현
  5. 헬스 체크 및 장애 복구 메커니즘
- **완료 기준:** Agent 간 메시지 전달 정상 동작, 지연시간 < 100ms

### Task 3.2 — Quality Gate Agent 3~4 구현
- **담당:** 백엔드 개발자
- **작업 내용:**
  1. **Gate 3 (Integration Agent):**
     - 기존 테스트 스위트 자동 실행
     - 영향 범위 분석 → 관련 테스트만 선별 실행
     - 테스트 실패 시 원인 분석 리포트
  2. **Gate 4 (Review Agent):**
     - AI 교차 코드 리뷰 (보안 취약점, 성능 이슈)
     - OWASP Top 10 자동 검사
     - 성능 안티패턴 탐지
- **완료 기준:** PR 생성 시 자동 리뷰 코멘트 생성

### Task 3.3 — Quality Gate Agent 6 (Collision Agent) 구현
- **담당:** 풀스택 개발자
- **작업 내용:**
  1. 팀원 작업 영역 등록/조회 API
  2. 파일 수준 충돌 감지 알고리즘
  3. 함수/모듈 수준 의미적 충돌 감지
  4. 충돌 감지 시 관련 팀원 자동 알림
  5. 충돌 해결 제안 생성
- **완료 기준:** 동시 수정 파일 충돌을 사전에 90%+ 감지

### Task 3.4 — Work Zone Isolation (작업 영역 분리)
- **담당:** 백엔드 개발자
- **작업 내용:**
  1. 작업 시작 시 수정 예상 파일 선언 API
  2. MCP를 통한 팀 전체 작업 영역 공유
  3. 영역 중복 시 경고 및 조율 메커니즘
  4. 작업 완료 시 영역 자동 해제
- **완료 기준:** 팀원 간 작업 영역이 실시간 공유됨

### Task 3.5 — Decision Extractor Agent 구현
- **담당:** ML 엔지니어
- **작업 내용:**
  1. AI 대화 로그에서 설계 결정 패턴 탐지
  2. 결정 사항 구조화 (제목, 컨텍스트, 결정, 근거, 대안)
  3. 팀 ADR에 자동 반영
  4. 관련 팀원 알림 (Slack/Discord 연동)
  5. 결정 이력 추적 및 변경 감지
- **완료 기준:** AI 대화에서 설계 결정 자동 추출률 80%+

### Task 3.6 — Agent 체인 오케스트레이션
- **담당:** 백엔드 아키텍트
- **작업 내용:**
  1. Gate 1→2→3→4→5→6 순차 실행 파이프라인
  2. 각 Gate 실패 시 중단/경고/자동 수정 정책
  3. Gate 실행 결과 대시보드 (로그 수집)
  4. Gate 바이패스 정책 (긴급 핫픽스 등)
  5. 전체 파이프라인 실행 시간 최적화 (병렬화)
- **완료 기준:** 전체 6-Gate 파이프라인이 5분 이내 완료

---

## 5. Phase 4 — 플랫폼화 (Layer 5: 팀 인텔리전스 대시보드)

> **목표:** 팀 인텔리전스 대시보드 + IDE 플러그인 + 온보딩 자동화  
> **소요:** 3~6개월 | **비용:** 중비용

### Task 4.1 — 팀 인텔리전스 대시보드 설계
- **담당:** UI/UX 디자이너 + 프론트엔드 개발자
- **기술 스택:** Next.js + TailwindCSS + Chart.js/D3.js
- **작업 내용:**
  1. 대시보드 와이어프레임 및 UI 디자인
  2. 프로젝트 건강 지표 정의:
     - 코드 품질 점수 (Gate 통과율)
     - 아키텍처 일관성 지수
     - 기술 부채 추이
     - 테스트 커버리지
  3. AI 비용 관리 패널 (일별/주별/월별 사용량)
  4. 팀원별 작업 현황 뷰
  5. ADR 타임라인 뷰
- **완료 기준:** 대시보드 프로토타입 완성, 팀 리뷰 통과

### Task 4.2 — 대시보드 백엔드 API 구현
- **담당:** 백엔드 개발자
- **기술 스택:** FastAPI / Express.js
- **작업 내용:**
  1. 지표 수집 API (Gate 결과, 비용, 활동 로그)
  2. 실시간 데이터 스트리밍 (WebSocket)
  3. 히스토리 데이터 저장 및 조회
  4. 알림 시스템 (임계값 초과 시 경고)
  5. 인증 및 권한 관리
- **완료 기준:** 모든 지표 API 응답 < 200ms

### Task 4.3 — IDE 플러그인 개발 (cursor-vibex)
- **담당:** 플러그인 개발자
- **기술 스택:** VSCode Extension API
- **작업 내용:**
  1. RAG 검색 패널 (사이드바)
  2. 팀원 작업 영역 시각화
  3. Gate 검증 결과 인라인 표시
  4. ADR 빠른 조회/작성
  5. 충돌 감지 경고 팝업
  6. PACT-D 프롬프트 자동 완성
- **완료 기준:** Cursor/VSCode에서 플러그인 설치 후 정상 동작

### Task 4.4 — RAG 기반 온보딩 자동 브리핑
- **담당:** ML 엔지니어 + 풀스택 개발자
- **작업 내용:**
  1. 신규 팀원 온보딩 시나리오 정의
  2. 프로젝트 컨텍스트 자동 요약 생성
  3. "이 프로젝트는 무엇인가?" → RAG 기반 Q&A
  4. 주요 설계 결정 히스토리 브리핑
  5. 담당 모듈 관련 코드 가이드 투어
- **완료 기준:** 새 팀원 온보딩 시간 2~3일 이내

### Task 4.5 — 피드백 루프 완전 자동화
- **담당:** 백엔드 아키텍트
- **작업 내용:**
  1. 생성 → 검증 → 기록 → 학습의 순환 파이프라인
  2. Gate 결과 기반 규칙 자동 업데이트
  3. 반복 실패 패턴 탐지 → 팀 규칙 제안
  4. AI 응답 품질 추적 및 프롬프트 최적화
  5. 월별 자동 리포트 생성
- **완료 기준:** 수동 개입 없이 품질 개선 사이클 동작

---

## 6. 기술 스택 종합

| 영역 | 기술/도구 | 선정 이유 |
|------|----------|----------|
| IDE | Cursor / Continue.dev | 오픈소스, RAG 지원, MCP 연동 |
| Vector DB | LanceDB / ChromaDB | 임베디드 모드, 무료, 빠른 속도 |
| 임베딩 모델 | Voyage-code-3 | 코드 이해도 최상위 |
| Orchestration | LangChain / LlamaIndex | RAG 파이프라인 표준 |
| 자동화 | Git Hooks (Husky) | 커밋 시점 강제 인덱싱 |
| 통신 프로토콜 | MCP (Model Context Protocol) | 표준 통신 계층 |
| 프론트엔드 | Next.js + TailwindCSS | 모던 대시보드 |
| 백엔드 | FastAPI / Express.js | 빠른 API 개발 |
| 알림 | Slack / Discord Webhook | 팀 커뮤니케이션 |

---

## 7. 리스크 관리

| 리스크 | 영향도 | 발생 가능성 | 대응 전략 |
|--------|--------|------------|----------|
| 팀원 프로세스 저항 | 높음 | 중간 | Phase 1부터 점진적 도입, 기존 워크플로우 보완 강조 |
| RAG 검색 정확도 부족 | 중간 | 중간 | 청킹 전략 반복 실험, 피드백 루프로 지속 개선 |
| MCP 통신 지연 | 중간 | 낮음 | 로컬 캐싱, 비동기 처리, 타임아웃 정책 |
| Agent 비용 초과 | 중간 | 낮음 | Gate 1,2,5,6은 비용 $0, 고비용 Gate는 선택적 실행 |
| Vector DB 스케일링 | 낮음 | 낮음 | 임베디드 → 서버 모드 마이그레이션 경로 확보 |

---

## 8. 성공 지표 (KPI)

| 지표 | Phase 2 완료 시 | Phase 3 완료 시 | Phase 4 완료 시 |
|------|----------------|----------------|----------------|
| 컨텍스트 유지율 | 95% | 95% | 98% |
| 아키텍처 일관성 | 70% | 85% | 90% |
| 통합 충돌률 | 30% | 15% | 12% |
| 설계 결정 추적률 | 50% | 75% | 85% |
| 온보딩 시간 | 1~2주 | 1주 | 2~3일 |
| 월 AI 비용 (5인) | ~$200 | ~$120 | ~$108 |

---

## 9. 팀 규모별 적용 전략

| 규모 | 핵심 전략 | 권장 Phase |
|------|----------|-----------|
| 소규모 (2~5명) | 문서 기반 소통 + 선택적 자동화 | Phase 1~3 |
| 중규모 (6~15명) | 서브팀 구조 + 인터페이스 계약 필수 | Phase 1~4 전체 |
| 대규모 (15명+) | 전용 플랫폼 + 조직별 커스터마이징 | Phase 4 확장 |

---

> **"바이브 코딩의 다음 단계는 더 좋은 모델이 아니라, 더 좋은 시스템에 있다."**  
> — 팀 바이브제왕
